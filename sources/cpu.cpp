/*!
    @file
    @brief CPU Emulator for machine code
*/
#include <cassert>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <stack>

#include "code.hpp"
#include "config.hpp"
#include "constants.hpp"

/*!
    @brief CPU Emulator

    Executes machine code, that was generated by Assembler
*/
class CPU {
public:
    CPU();
    ~CPU();

    void LoadBinary(const char* file_path);

    void Execute();

private:
    #define REGISTER(NAME, CODE) \
        int NAME = 0;

    #include "registers.hpp"

    #undef REGISTER

    Code<int> machine;
    int offset;

    std::stack<int> stack;
    
    int GetRegisterData(int register_code);
    void UpdateRegister(int register_code, int value);
};

/*!
    @brief Returns data from register
    @param[in] register_code Register's code from constants.hpp
    @param[out] data Data, stored in register
*/
int CPU::GetRegisterData(int register_code) {
    #define REGISTER(NAME, CODE) \
        case CODE: \
            return NAME;

    switch (register_code) {
        #include "registers.hpp"

        default:
            return -1;
    }

    #undef REGISTER
}

/*!
    @brief Writes new value to register
    @param[in] register_code Register's code from constants.hpp
    @param[out] . No return value
*/
void CPU::UpdateRegister(int register_code, int value) {
    #define REGISTER(NAME, CODE) \
       case CODE: \
           NAME = value; \
           break;

    switch (register_code) {
        #include "registers.hpp"

        default:
            break;
    }

    #undef REGISTER
}

CPU::CPU() {
    machine.code = (int*) calloc(PPTSM_PROCESS_MEMORY_SIZE, sizeof(int));
}

CPU::~CPU() {
    machine.~Code();
}

/*!
    @brief Load machine code from file
    @param[in] file_path Path to binary file
    @param[out] . No return value
*/
void CPU::LoadBinary(const char* file_path) {
    FILE* machine_file = fopen(file_path, "rb");
    assert(machine_file);

    fseek(machine_file, 0, SEEK_END);
    machine.size = ftell(machine_file) / sizeof(int);
    fseek(machine_file, 0, SEEK_SET);

    assert(machine.code);
    int read_count = fread(machine.code, sizeof(int), machine.size, machine_file);
    assert(read_count == machine.size);

    offset = machine.code[0];

    int close_result = fclose(machine_file);
    assert(close_result != EOF);
}

/*!
    @brief Executes machine code
    @param[in] . No input value
    @param[out] . No return value
*/
void CPU::Execute() {
    int curr_cell = offset;

    bool active = true;
    while (active && curr_cell < machine.size) {
        #define INSTRUCTION(NAME, CODE, ACTION) \
            case CODE: \
                ACTION \
                break;

        switch (machine.code[curr_cell]) {
            #include "instructions.hpp"
        }

        ++curr_cell;
    }

    #undef INSTRUCTION
}

int main(int argc, char** argv) {
    CPU cpu;

    cpu.LoadBinary(argv[1]);

    cpu.Execute();
}
